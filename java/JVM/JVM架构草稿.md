10JVM整体架构

![image-20201125222843726](JVM架构.assets/image-20201125222843726.png)

详细图

![image-20201129100215780](JVM架构.assets/image-20201129100215780.png)



中文版

![image-20201129100252111](JVM架构.assets/image-20201129100252111.png)

代码执行流程

![image-20201125223323375](JVM架构.assets/image-20201125223323375.png)

只要遵循字节码规范，就可以被JVM执行

编译器有解释执行器呵JIT即时编译器两部分合用组成。

JIT编译器，对字节码进行二次编译，直接生产二进制代码。好处是以后执行会更快，效率更高。用于反复执行的热点代码。



java是基于栈的架构

指令集更少，但是实现一个功能的需要的指令更多。性能比基于寄存器的架构差。但是需要的资源少，可移植性更强



类加载器，getClassLoader方法和getClass方法

![image-20201129103116433](JVM架构.assets/image-20201129103116433.png)

类加载过程

![image-20201129103407628](JVM架构.assets/image-20201129103407628.png)

#### 自定义类加载器

原因：

1. 隔离加载类，避免类冲突

2. 修改类加载的方式

3. 扩展加载源

4. 防止源码卸载。对源码进行加密。使用自定义类加载器进行解密

   

步骤

####    运行时方法区

![image-20201204213522142](JVM架构.assets/image-20201204213522142.png)



栈帧

![image-20201206224103947](JVM架构.assets/image-20201206224103947.png)





![image-20201209091620968](JVM架构.assets/image-20201209091620968.png)





![image-20201212211214385](JVM架构.assets/image-20201212211214385.png)

 

![image-20201217213358857](JVM架构.assets/image-20201217213358857.png)



对象存储

![image-20201219220350869](JVM架构.assets/image-20201219220350869.png)



#### 垃圾收集器

![image-20201225220215577](JVM架构.assets/image-20201225220215577.png)

红色的线，已废弃

绿色的线，jdk14废弃



![image-20201230112543975](JVM架构.assets/image-20201230112543975.png)